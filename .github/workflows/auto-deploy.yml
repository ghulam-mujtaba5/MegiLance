name: Build and Deploy Application

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      deploy_backend:
        description: 'Deploy backend'
        required: true
        default: true
        type: boolean
      deploy_frontend:
        description: 'Deploy frontend'
        required: true
        default: true
        type: boolean

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-2
  ECR_BACKEND: megilance-backend
  ECR_FRONTEND: megilance-frontend
  ECS_CLUSTER: megilance-cluster
  ECS_BACKEND_SERVICE: megilance-backend-service
  ECS_FRONTEND_SERVICE: megilance-frontend-service

jobs:
  build-and-push-backend:
    name: Build & Push Backend
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_backend }}
    outputs:
      image_uri: ${{ steps.push.outputs.image_uri }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-backend
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build backend image
        id: build
        working-directory: backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG $ECR_REGISTRY/${{ env.ECR_BACKEND }}:latest
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Push backend image
        id: push
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.build.outputs.image_tag }}
        run: |
          docker push $ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_BACKEND }}:latest
          echo "image_uri=$ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Image vulnerability scan
        continue-on-error: true
        run: |
          aws ecr start-image-scan \
            --repository-name ${{ env.ECR_BACKEND }} \
            --image-id imageTag=${{ steps.build.outputs.image_tag }}

  build-and-push-frontend:
    name: Build & Push Frontend
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_frontend }}
    outputs:
      image_uri: ${{ steps.push.outputs.image_uri }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-frontend
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build frontend image
        id: build
        working-directory: frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/${{ env.ECR_FRONTEND }}:$IMAGE_TAG \
            --build-arg NEXT_PUBLIC_API_URL=https://api.megilance.com \
            .
          docker tag $ECR_REGISTRY/${{ env.ECR_FRONTEND }}:$IMAGE_TAG $ECR_REGISTRY/${{ env.ECR_FRONTEND }}:latest
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Push frontend image
        id: push
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.build.outputs.image_tag }}
        run: |
          docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND }}:latest
          echo "image_uri=$ECR_REGISTRY/${{ env.ECR_FRONTEND }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

  run-database-migrations:
    name: Run Database Migrations
    needs: build-and-push-backend
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_backend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-migrations
          aws-region: ${{ env.AWS_REGION }}

      - name: Get database secret from Secrets Manager
        id: db_secret
        run: |
          # Try to fetch the secret value from Secrets Manager. The secret is expected
          # to be a JSON string containing DATABASE_URL or individual fields.
          echo "Fetching secret: megilance/prod/database"
          SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id megilance/prod/database --region $AWS_REGION --query SecretString --output text) || (
            echo "Failed to read secret megilance/prod/database" >&2; exit 1)
          echo "secret_json=$SECRET_JSON" >> $GITHUB_OUTPUT

      - name: Run Alembic migrations
        env:
          # Prefer a full DATABASE_URL in the secret, otherwise construct it from parts
          DATABASE_URL: ${{ fromJson( steps.db_secret.outputs.secret_json ).DATABASE_URL || format('postgresql://%s:%s@%s/%s', fromJson( steps.db_secret.outputs.secret_json ).username, fromJson( steps.db_secret.outputs.secret_json ).password, fromJson( steps.db_secret.outputs.secret_json ).host, fromJson( steps.db_secret.outputs.secret_json ).dbname ) }}
        run: |
          set -eux
          cd backend
          python -V || true
          pip install --upgrade pip
          pip install alembic psycopg2-binary || true
          echo "DATABASE_URL=$DATABASE_URL"
          # Validate connection before running migrations
          python - <<PY
import os
import sys
from urllib.parse import urlparse
import psycopg2
u=os.getenv('DATABASE_URL')
if not u:
    print('DATABASE_URL not set', file=sys.stderr); sys.exit(2)
o=urlparse(u)
conn=psycopg2.connect(dbname=o.path.lstrip('/'), user=o.username, password=o.password, host=o.hostname, port=o.port or 5432)
conn.close()
print('DB connection OK')
PY
          alembic upgrade head

  deploy-backend-to-ecs:
    name: Deploy Backend to ECS
    needs: [build-and-push-backend, run-database-migrations]
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_backend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-deploy-backend
          aws-region: ${{ env.AWS_REGION }}

      - name: Create/Update task definition
        id: task-def
        run: |
          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition megilance-backend \
            --query 'taskDefinition' || echo '{}')
          
          # Create new task definition with updated image
          cat > task-def.json <<EOF
          {
            "family": "megilance-backend",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "512",
            "memory": "1024",
            "executionRoleArn": "$(aws iam get-role --role-name megilance-exec-role --query 'Role.Arn' --output text)",
            "taskRoleArn": "$(aws iam get-role --role-name megilance-task-role --query 'Role.Arn' --output text)",
            "containerDefinitions": [
              {
                "name": "backend",
                "image": "${{ needs.build-and-push-backend.outputs.image_uri }}",
                "portMappings": [
                  {
                    "containerPort": 8000,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "environment": [
                  {
                    "name": "ENVIRONMENT",
                    "value": "${{ inputs.environment }}"
                  }
                ],
                "secrets": [
                  {
                    "name": "DATABASE_URL",
                    "valueFrom": "arn:aws:secretsmanager:${{ env.AWS_REGION }}:$(aws sts get-caller-identity --query Account --output text):secret:megilance/prod/database"
                  },
                  {
                    "name": "SECRET_KEY",
                    "valueFrom": "arn:aws:secretsmanager:${{ env.AWS_REGION }}:$(aws sts get-caller-identity --query Account --output text):secret:megilance/prod/jwt"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/megilance-backend",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "curl -f http://localhost:8000/api/health/live || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                }
              }
            ]
          }
          EOF
          
          # Register new task definition
          aws ecs register-task-definition --cli-input-json file://task-def.json

      - name: Update or Create ECS service
        run: |
          set -eux
          CLUSTER=${{ env.ECS_CLUSTER }}
          SERVICE=${{ env.ECS_BACKEND_SERVICE }}
          TASK_FAMILY=megilance-backend
          # Try update first
          if aws ecs describe-services --cluster $CLUSTER --services $SERVICE --region $AWS_REGION --query 'services[0].serviceName' --output text | grep -q $SERVICE; then
            echo "Service exists - updating"
            aws ecs update-service --cluster $CLUSTER --service $SERVICE --task-definition $TASK_FAMILY --force-new-deployment --region $AWS_REGION || echo "update-service returned non-zero";
          else
            echo "Service not found - creating"
            # create service (basic) - assumes subnets/security groups created by infra
            aws ecs create-service --cluster $CLUSTER --service-name $SERVICE --task-definition $TASK_FAMILY --desired-count 1 --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[${{ env.PUBLIC_SUBNETS || '' }}],assignPublicIp=ENABLED,securityGroups=[]}" --region $AWS_REGION || (echo "create-service failed"; exit 1)
          fi

      - name: Wait for service stability
        run: |
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_BACKEND_SERVICE }}

  deploy-frontend-to-ecs:
    name: Deploy Frontend to ECS
    needs: build-and-push-frontend
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_frontend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-deploy-frontend
          aws-region: ${{ env.AWS_REGION }}

      - name: Create/Update task definition
        run: |
          cat > task-def-frontend.json <<EOF
          {
            "family": "megilance-frontend",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "$(aws iam get-role --role-name megilance-exec-role --query 'Role.Arn' --output text)",
            "containerDefinitions": [
              {
                "name": "frontend",
                "image": "${{ needs.build-and-push-frontend.outputs.image_uri }}",
                "portMappings": [
                  {
                    "containerPort": 3000,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "environment": [
                  {
                    "name": "NODE_ENV",
                    "value": "production"
                  },
                  {
                    "name": "NEXT_PUBLIC_API_URL",
                    "value": "https://api.megilance.com"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/megilance-frontend",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                }
              }
            ]
          }
          EOF
          
          aws ecs register-task-definition --cli-input-json file://task-def-frontend.json

      - name: Update or Create frontend ECS service
        run: |
          set -eux
          CLUSTER=${{ env.ECS_CLUSTER }}
          SERVICE=${{ env.ECS_FRONTEND_SERVICE }}
          TASK_FAMILY=megilance-frontend
          if aws ecs describe-services --cluster $CLUSTER --services $SERVICE --region $AWS_REGION --query 'services[0].serviceName' --output text | grep -q $SERVICE; then
            echo "Frontend service exists - updating"
            aws ecs update-service --cluster $CLUSTER --service $SERVICE --task-definition $TASK_FAMILY --force-new-deployment --region $AWS_REGION || echo "update-service returned non-zero";
          else
            echo "Frontend service not found - creating"
            aws ecs create-service --cluster $CLUSTER --service-name $SERVICE --task-definition $TASK_FAMILY --desired-count 1 --launch-type FARGATE --network-configuration "awsvpcConfiguration={subnets=[${{ env.PUBLIC_SUBNETS || '' }}],assignPublicIp=ENABLED,securityGroups=[]}" --region $AWS_REGION || (echo "create-service failed"; exit 1)
          fi

      - name: Wait for service stability
        run: |
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_FRONTEND_SERVICE }}

  smoke-tests:
    name: Run Smoke Tests
    needs: [deploy-backend-to-ecs, deploy-frontend-to-ecs]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-smoke-tests
          aws-region: ${{ env.AWS_REGION }}

      - name: Get service endpoints (with diagnostics)
        id: endpoints
        run: |
          set -eux
          CLUSTER=${{ env.ECS_CLUSTER }}
          SERVICE=${{ env.ECS_BACKEND_SERVICE }}
          # List tasks - may be empty
          TASK_ARN=$(aws ecs list-tasks --cluster $CLUSTER --service-name $SERVICE --region $AWS_REGION --query 'taskArns[0]' --output text || true)
          echo "task_arn=$TASK_ARN" >> $GITHUB_OUTPUT
          if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" = "None" ]; then
            echo "No task found for service $SERVICE" >&2
            aws ecs describe-services --cluster $CLUSTER --services $SERVICE --region $AWS_REGION --query 'services[0].events' --output json || true
            echo "backend_url=" >> $GITHUB_OUTPUT
            exit 0
          fi
          BACKEND_IP=$(aws ecs describe-tasks --cluster $CLUSTER --tasks $TASK_ARN --region $AWS_REGION --query 'tasks[0].containers[0].networkInterfaces[0].privateIpv4Address' --output text)
          echo "backend_url=http://$BACKEND_IP:8000" >> $GITHUB_OUTPUT

      - name: Test backend health
        run: |
          if [ -z "${{ steps.endpoints.outputs.backend_url }}" ]; then
            echo "No backend URL available, skipping health checks"; exit 0
          fi
          curl -f ${{ steps.endpoints.outputs.backend_url }}/api/health/live || (aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_BACKEND_SERVICE }} --region $AWS_REGION --query 'services[0].events' --output json; exit 1)
          curl -f ${{ steps.endpoints.outputs.backend_url }}/api/health/ready || (aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_BACKEND_SERVICE }} --region $AWS_REGION --query 'services[0].events' --output json; exit 1)

      - name: Test API documentation
        run: |
          curl -f ${{ steps.endpoints.outputs.backend_url }}/api/docs || exit 1

  notify-deployment:
    name: Notify Deployment Status
    needs: [deploy-backend-to-ecs, deploy-frontend-to-ecs, smoke-tests]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend deployed**: ${{ inputs.deploy_backend }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend deployed**: ${{ inputs.deploy_frontend }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Status" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
