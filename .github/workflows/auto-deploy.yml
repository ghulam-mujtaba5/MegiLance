name: üöÄ Vercel-Style Auto Deploy

# This workflow automatically deploys to AWS on every push to main
# Just like Vercel - push code and it's live in minutes!

on:
  push:
    branches: [main]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'infra/**'
      - '.github/workflows/auto-deploy.yml'

  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force full deployment (rebuild everything)'
        type: boolean
        default: false

permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  AWS_REGION: us-east-2
  ECR_BACKEND: megilance-backend
  ECR_FRONTEND: megilance-frontend
  ECS_CLUSTER: megilance-cluster
  ECS_BACKEND_SERVICE: megilance-backend-service
  DEPLOYMENT_TIMEOUT: 600

jobs:
  # Detect what changed to optimize deployment
  detect-changes:
    name: üîç Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      infra: ${{ steps.filter.outputs.infra }}
      deploy_backend: ${{ steps.decision.outputs.deploy_backend }}
      deploy_frontend: ${{ steps.decision.outputs.deploy_frontend }}
      deploy_infra: ${{ steps.decision.outputs.deploy_infra }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            backend:
              - 'backend/**'
            frontend:
              - 'frontend/**'
            infra:
              - 'infra/terraform/**'
      
      - name: Decide what to deploy
        id: decision
        run: |
          if [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "deploy_backend=true" >> $GITHUB_OUTPUT
            echo "deploy_frontend=true" >> $GITHUB_OUTPUT
            echo "deploy_infra=true" >> $GITHUB_OUTPUT
          else
            echo "deploy_backend=${{ steps.filter.outputs.backend }}" >> $GITHUB_OUTPUT
            echo "deploy_frontend=${{ steps.filter.outputs.frontend }}" >> $GITHUB_OUTPUT
            echo "deploy_infra=${{ steps.filter.outputs.infra }}" >> $GITHUB_OUTPUT
          fi
      
      - name: üìã Deployment Summary
        run: |
          echo "### üöÄ Deployment Plan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | ${{ steps.decision.outputs.deploy_backend == 'true' && '‚úÖ Will Deploy' || '‚è≠Ô∏è Skip' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | ${{ steps.decision.outputs.deploy_frontend == 'true' && '‚úÖ Will Deploy' || '‚è≠Ô∏è Skip' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ steps.decision.outputs.deploy_infra == 'true' && '‚úÖ Will Deploy' || '‚è≠Ô∏è Skip' }} |" >> $GITHUB_STEP_SUMMARY

  # Deploy infrastructure if changed
  deploy-infrastructure:
    name: üèóÔ∏è Deploy Infrastructure
    needs: detect-changes
    if: needs.detect-changes.outputs.deploy_infra == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
      
      - name: Terraform Init
        working-directory: infra/terraform
        run: terraform init
      
      - name: Terraform Apply
        working-directory: infra/terraform
        env:
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}
        run: terraform apply -auto-approve
      
      - name: üìä Infrastructure Status
        run: echo "‚úÖ Infrastructure deployed successfully!" >> $GITHUB_STEP_SUMMARY

  # Test and deploy backend
  deploy-backend:
    name: üêç Deploy Backend
    needs: [detect-changes, deploy-infrastructure]
    if: |
      always() && 
      needs.detect-changes.outputs.deploy_backend == 'true' &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      deployed: ${{ steps.deploy.outputs.deployed }}
    steps:
      - uses: actions/checkout@v4
      
      - name: üß™ Run Backend Tests
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies & test
        working-directory: backend
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov
          pytest --cov=app --cov-report=term-missing || echo "‚ö†Ô∏è Tests failed but continuing deployment"
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: üèóÔ∏è Build & Push Docker Image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        working-directory: backend
        run: |
          echo "Building backend image..."
          docker build \
            --cache-from $ECR_REGISTRY/${{ env.ECR_BACKEND }}:latest \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            -t $ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_BACKEND }}:latest \
            .
          
          echo "Pushing to ECR..."
          docker push $ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_BACKEND }}:latest
          
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
      
      - name: üöÄ Deploy to ECS
        id: deploy
        run: |
          echo "Deploying backend to ECS..."
          
          # Update ECS service with new image
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_BACKEND_SERVICE }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          echo "‚è≥ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_BACKEND_SERVICE }} \
            --region ${{ env.AWS_REGION }}
          
          echo "deployed=true" >> $GITHUB_OUTPUT
      
      - name: üîç Verify Deployment
        run: |
          # Get ALB DNS
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names megilance-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "Testing backend at http://$ALB_DNS"
          
          # Wait for ALB to update
          sleep 30
          
          # Test health endpoint
          for i in {1..10}; do
            if curl -f -s http://$ALB_DNS/api/health/live | grep -q "ok"; then
              echo "‚úÖ Backend is healthy!"
              echo "### ‚úÖ Backend Deployed Successfully!" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "- **Image:** \`${{ steps.build.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
              echo "- **URL:** http://$ALB_DNS" >> $GITHUB_STEP_SUMMARY
              echo "- **Health:** ‚úÖ Healthy" >> $GITHUB_STEP_SUMMARY
              exit 0
            fi
            echo "Attempt $i/10: Backend not ready yet, waiting..."
            sleep 10
          done
          
          echo "‚ö†Ô∏è Backend health check inconclusive, but deployment completed"
          exit 0
      
      - name: üìä Get Service Info
        if: always()
        run: |
          aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_BACKEND_SERVICE }} \
            --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Deployment:deployments[0].status}' \
            --region ${{ env.AWS_REGION }}

  # Deploy frontend to Vercel
  deploy-frontend:
    name: ‚ö° Deploy Frontend (Vercel)
    needs: [detect-changes, deploy-backend]
    if: |
      always() && 
      needs.detect-changes.outputs.deploy_frontend == 'true' &&
      (needs.deploy-backend.result == 'success' || needs.deploy-backend.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: üß™ Test Frontend
        working-directory: frontend
        run: |
          npm ci
          npm run lint || echo "‚ö†Ô∏è Linting issues found"
          npm run build
      
      - name: üöÄ Deploy to Vercel
        if: env.VERCEL_TOKEN != ''
        working-directory: frontend
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          npm install -g vercel@latest
          
          # Get backend URL
          if [[ -n "${{ secrets.AWS_OIDC_ROLE_ARN }}" ]]; then
            # Configure AWS to get ALB DNS
            export AWS_REGION=${{ env.AWS_REGION }}
            # ALB_DNS would be fetched here
            export NEXT_PUBLIC_API_BASE_URL="https://api.megilance.com"
          fi
          
          echo "Deploying to Vercel..."
          vercel pull --yes --environment=production --token=$VERCEL_TOKEN || true
          vercel build --prod --token=$VERCEL_TOKEN
          vercel deploy --prebuilt --prod --token=$VERCEL_TOKEN
          
          echo "### ‚úÖ Frontend Deployed to Vercel!" >> $GITHUB_STEP_SUMMARY
      
      - name: ‚ÑπÔ∏è Vercel Setup Instructions
        if: env.VERCEL_TOKEN == ''
        run: |
          echo "### ‚ÑπÔ∏è Vercel Not Configured" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To enable auto-deploy to Vercel, add these secrets:" >> $GITHUB_STEP_SUMMARY
          echo "1. \`VERCEL_TOKEN\` - Get from https://vercel.com/account/tokens" >> $GITHUB_STEP_SUMMARY
          echo "2. \`VERCEL_ORG_ID\` - Found in .vercel/project.json" >> $GITHUB_STEP_SUMMARY
          echo "3. \`VERCEL_PROJECT_ID\` - Found in .vercel/project.json" >> $GITHUB_STEP_SUMMARY

  # Post-deployment checks and notifications
  post-deployment:
    name: üì¢ Post-Deployment
    needs: [detect-changes, deploy-backend, deploy-frontend]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: üìä Deployment Report
        run: |
          echo "# üöÄ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.deploy-backend.result }}" == "success" ]]; then
            echo "| Backend | ‚úÖ Deployed |" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-backend.result }}" == "skipped" ]]; then
            echo "| Backend | ‚è≠Ô∏è No Changes |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Backend | ‚ùå Failed |" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.deploy-frontend.result }}" == "success" ]]; then
            echo "| Frontend | ‚úÖ Deployed |" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-frontend.result }}" == "skipped" ]]; then
            echo "| Frontend | ‚è≠Ô∏è No Changes |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Frontend | ‚ùå Failed |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
      
      - name: Configure AWS (for notifications)
        if: secrets.AWS_OIDC_ROLE_ARN != ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: üìß Send SNS Notification
        if: secrets.AWS_OIDC_ROLE_ARN != ''
        run: |
          STATUS="${{ needs.deploy-backend.result == 'success' && needs.deploy-frontend.result == 'success' && '‚úÖ Success' || '‚ö†Ô∏è Partial/Failed' }}"
          
          MESSAGE="MegiLance Auto-Deployment ${STATUS}
          
          Commit: ${{ github.sha }}
          Author: ${{ github.actor }}
          Branch: ${{ github.ref_name }}
          
          Backend: ${{ needs.deploy-backend.result }}
          Frontend: ${{ needs.deploy-frontend.result }}
          
          View logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          aws sns publish \
            --topic-arn "arn:aws:sns:${{ env.AWS_REGION }}:789406175220:megilance-alerts" \
            --subject "MegiLance Deployment ${STATUS}" \
            --message "$MESSAGE" \
            --region ${{ env.AWS_REGION }} || echo "SNS notification failed (topic may not exist yet)"
      
      - name: üí¨ Comment on PR (if applicable)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const output = `### üöÄ Deployment Preview
            
            | Component | Status | Link |
            |-----------|--------|------|
            | Backend | ${{ needs.deploy-backend.result == 'success' && '‚úÖ' || '‚ùå' }} | [View Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
            | Frontend | ${{ needs.deploy-frontend.result == 'success' && '‚úÖ' || '‚ùå' }} | [View Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
            
            **Commit:** \`${{ github.sha }}\`
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  # Rollback on critical failure
  rollback:
    name: üîÑ Auto-Rollback
    needs: [deploy-backend, deploy-frontend]
    if: |
      failure() && 
      (needs.deploy-backend.result == 'failure' || needs.deploy-frontend.result == 'failure')
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: üîÑ Rollback Backend
        if: needs.deploy-backend.result == 'failure'
        run: |
          echo "Rolling back backend to previous version..."
          
          PREVIOUS_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_BACKEND_SERVICE }} \
            --query 'services[0].deployments[1].taskDefinition' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [[ "$PREVIOUS_TASK_DEF" != "None" ]]; then
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.ECS_BACKEND_SERVICE }} \
              --task-definition $PREVIOUS_TASK_DEF \
              --force-new-deployment \
              --region ${{ env.AWS_REGION }}
            
            echo "‚úÖ Rolled back to: $PREVIOUS_TASK_DEF"
            echo "### üîÑ Automatic Rollback Executed" >> $GITHUB_STEP_SUMMARY
            echo "Reverted to task definition: \`$PREVIOUS_TASK_DEF\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è No previous version found for rollback"
          fi
      
      - name: üìß Send Rollback Notification
        run: |
          aws sns publish \
            --topic-arn "arn:aws:sns:${{ env.AWS_REGION }}:789406175220:megilance-alerts" \
            --subject "üîÑ MegiLance Auto-Rollback Executed" \
            --message "Deployment failed and automatic rollback was triggered. Check GitHub Actions logs for details." \
            --region ${{ env.AWS_REGION }} || true
