name: Build and Deploy Application

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      deploy_backend:
        description: 'Deploy backend'
        required: true
        default: true
        type: boolean
      deploy_frontend:
        description: 'Deploy frontend'
        required: true
        default: true
        type: boolean

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-2
  ECR_BACKEND: megilance-backend
  ECR_FRONTEND: megilance-frontend
  ECS_CLUSTER: megilance-cluster
  ECS_BACKEND_SERVICE: megilance-backend-service
  ECS_FRONTEND_SERVICE: megilance-frontend-service

jobs:
  preflight-fixes:
    name: Preflight IAM and Service Tuning
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-preflight
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure exec role has Secrets Manager access (best-effort)
        continue-on-error: true
        run: |
          set -e
          echo "ðŸ” Ensuring megilance-exec-role has Secrets Manager access..."
          ACCOUNT=$(aws sts get-caller-identity --query 'Account' --output text)
          cat > secrets-policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "secretsmanager:GetSecretValue",
                  "secretsmanager:DescribeSecret"
                ],
                "Resource": [
                  "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${ACCOUNT}:secret:megilance/prod/database-*",
                  "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${ACCOUNT}:secret:megilance/prod/jwt-*"
                ]
              },
              {
                "Effect": "Allow",
                "Action": [
                  "kms:Decrypt",
                  "kms:DescribeKey"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF
          EXISTING=$(aws iam list-policies --scope Local --query "Policies[?PolicyName=='megilance-secrets-access'].Arn" --output text || true)
          if [ -z "$EXISTING" ]; then
            POLICY_ARN=$(aws iam create-policy --policy-name megilance-secrets-access --policy-document file://secrets-policy.json --query 'Policy.Arn' --output text)
            echo "âœ… Created policy: $POLICY_ARN"
          else
            POLICY_ARN="$EXISTING"
            echo "â„¹ï¸ Policy exists: $POLICY_ARN"
          fi
          ATTACHED=$(aws iam list-attached-role-policies --role-name megilance-exec-role --query 'AttachedPolicies[?PolicyName==`megilance-secrets-access`].PolicyArn' --output text || true)
          if [ -z "$ATTACHED" ]; then
            aws iam attach-role-policy --role-name megilance-exec-role --policy-arn "$POLICY_ARN"
            echo "âœ… Attached policy to exec role"
          else
            echo "â„¹ï¸ Policy already attached"
          fi

      - name: Secrets existence & read check (best-effort)
        continue-on-error: true
        run: |
          echo "ðŸ”Ž Checking Secrets Manager secrets existence and read access (best-effort)"
          SECRETS=("megilance/prod/database" "megilance/prod/jwt")
          for S in "${SECRETS[@]}"; do
            echo "-- Checking $S --"
            aws secretsmanager describe-secret --secret-id "$S" --region ${{ env.AWS_REGION }} --output json >/dev/null 2>&1 && echo "Found: $S" || echo "Missing: $S"
            # Try to read secret value to validate permissions (will be redacted in logs)
            set +e
            aws secretsmanager get-secret-value --secret-id "$S" --region ${{ env.AWS_REGION }} --query SecretString --output text >/dev/null 2>&1
            RC=$?
            set -e
            if [ $RC -eq 0 ]; then
              echo "Readable: $S"
            else
              echo "Unreadable or not accessible: $S (ensure exec role has secretsmanager:GetSecretValue)"
            fi
          done

      - name: Tune ECS health check grace periods (best-effort)
        continue-on-error: true
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_BACKEND_SERVICE }} \
            --health-check-grace-period-seconds 120 \
            --query 'service.{Name:serviceName,Grace:healthCheckGracePeriodSeconds}' \
            --output table || true
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_FRONTEND_SERVICE }} \
            --health-check-grace-period-seconds 60 \
            --query 'service.{Name:serviceName,Grace:healthCheckGracePeriodSeconds}' \
            --output table || true
  build-and-push-backend:
    name: Build & Push Backend
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_backend }}
    outputs:
      image_uri: ${{ steps.push.outputs.image_uri }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-backend
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build backend image
        id: build
        working-directory: backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG $ECR_REGISTRY/${{ env.ECR_BACKEND }}:latest
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Push backend image
        id: push
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.build.outputs.image_tag }}
        run: |
          docker push $ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_BACKEND }}:latest
          echo "image_uri=$ECR_REGISTRY/${{ env.ECR_BACKEND }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Image vulnerability scan
        continue-on-error: true
        run: |
          aws ecr start-image-scan \
            --repository-name ${{ env.ECR_BACKEND }} \
            --image-id imageTag=${{ steps.build.outputs.image_tag }}

  build-and-push-frontend:
    name: Build & Push Frontend
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_frontend }}
    outputs:
      image_uri: ${{ steps.push.outputs.image_uri }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-frontend
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build frontend image
        id: build
        working-directory: frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/${{ env.ECR_FRONTEND }}:$IMAGE_TAG \
            --build-arg NEXT_PUBLIC_API_URL=https://api.megilance.com \
            .
          docker tag $ECR_REGISTRY/${{ env.ECR_FRONTEND }}:$IMAGE_TAG $ECR_REGISTRY/${{ env.ECR_FRONTEND }}:latest
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Push frontend image
        id: push
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.build.outputs.image_tag }}
        run: |
          docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND }}:latest
          echo "image_uri=$ECR_REGISTRY/${{ env.ECR_FRONTEND }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

  run-database-migrations:
    name: Run Database Migrations
    needs: build-and-push-backend
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_backend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-migrations
          aws-region: ${{ env.AWS_REGION }}

      - name: Get database secret from Secrets Manager
        id: db_secret
        run: |
          # Try to fetch the secret value from Secrets Manager. The secret is expected
          # to be a JSON string containing DATABASE_URL or individual fields.
          echo "Fetching secret: megilance/prod/database"
          SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id megilance/prod/database --region $AWS_REGION --query SecretString --output text) || (
            echo "Failed to read secret megilance/prod/database" >&2; exit 1)
          echo "secret_json=$SECRET_JSON" >> $GITHUB_OUTPUT

      - name: Skip migrations (RDS is private)
        run: |
          echo "âš ï¸ SKIPPING database migrations in GitHub Actions"
          echo "RDS is in private subnet and not accessible from GitHub Actions runners"
          echo "âœ… Migrations will run automatically from ECS container on startup"
          echo "See backend/main.py startup event for migration logic"

  deploy-backend-to-ecs:
    name: Deploy Backend to ECS
    needs: [preflight-fixes, build-and-push-backend, run-database-migrations]
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_backend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-deploy-backend
          aws-region: ${{ env.AWS_REGION }}

      - name: Get VPC Configuration
        id: vpc-config
        run: |
          # Get VPC ID
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=megilance-vpc" \
            --query 'Vpcs[0].VpcId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "VPC ID: $VPC_ID"
          
          # Get public subnets - try multiple tag patterns
          PUBLIC_SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=tag:Name,Values=*-public-*" \
            --query 'Subnets[*].SubnetId' \
            --output text \
            --region ${{ env.AWS_REGION }} | tr '\t' ',')
          
          # Fallback: if no public subnets found, get ALL subnets in VPC
          if [ -z "$PUBLIC_SUBNETS" ]; then
            echo "No public subnets found with tag filter, getting all subnets in VPC"
            PUBLIC_SUBNETS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[*].SubnetId' \
              --output text \
              --region ${{ env.AWS_REGION }} | tr '\t' ',')
          fi
          
          echo "public_subnets=$PUBLIC_SUBNETS" >> $GITHUB_OUTPUT
          echo "Found subnets: $PUBLIC_SUBNETS"
          
          # Get security group
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=group-name,Values=megilance-ecs-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          if [ "$SG_ID" == "None" ] || [ -z "$SG_ID" ]; then
            # Get default security group if custom one doesn't exist
            SG_ID=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" "Name=group-name,Values=default" \
              --query 'SecurityGroups[0].GroupId' \
              --output text \
              --region ${{ env.AWS_REGION }})
          fi
          echo "security_group=$SG_ID" >> $GITHUB_OUTPUT
          echo "Found security group: $SG_ID"

      - name: Create/Update task definition
        id: task-def
        run: |
          # Get AWS account ID
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          
          # Get secret ARNs (including version suffix)
          DB_SECRET_ARN=$(aws secretsmanager describe-secret \
            --secret-id megilance/prod/database \
            --region ${{ env.AWS_REGION }} \
            --query 'ARN' --output text)
          
          JWT_SECRET_ARN=$(aws secretsmanager describe-secret \
            --secret-id megilance/prod/jwt \
            --region ${{ env.AWS_REGION }} \
            --query 'ARN' --output text)
          
          echo "Database Secret ARN: $DB_SECRET_ARN"
          echo "JWT Secret ARN: $JWT_SECRET_ARN"
          
          # Get execution role ARN
          EXEC_ROLE_ARN=$(aws iam get-role --role-name megilance-exec-role --query 'Role.Arn' --output text)
          TASK_ROLE_ARN=$(aws iam get-role --role-name megilance-task-role --query 'Role.Arn' --output text)
          
          echo "Execution Role ARN: $EXEC_ROLE_ARN"
          echo "Task Role ARN: $TASK_ROLE_ARN"
          
          # Create new task definition with updated image
          cat > task-def.json <<EOF
          {
            "family": "megilance-backend",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "512",
            "memory": "1024",
            "executionRoleArn": "$EXEC_ROLE_ARN",
            "taskRoleArn": "$TASK_ROLE_ARN",
            "containerDefinitions": [
              {
                "name": "backend",
                "image": "${{ needs.build-and-push-backend.outputs.image_uri }}",
                "portMappings": [
                  {
                    "containerPort": 8000,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "environment": [
                  {
                    "name": "ENVIRONMENT",
                    "value": "${{ inputs.environment }}"
                  }
                ],
                "secrets": [
                  {
                    "name": "DATABASE_URL",
                    "valueFrom": "$DB_SECRET_ARN:database_url::"
                  },
                  {
                    "name": "SECRET_KEY",
                    "valueFrom": "$JWT_SECRET_ARN:access_secret::"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/megilance-backend",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "healthCheck": {
                  "command": [
                    "CMD-SHELL",
                    "python -c \"import sys,urllib.request,socket; socket.setdefaulttimeout(3); r=urllib.request.urlopen('http://127.0.0.1:8000/api/health/live'); sys.exit(0 if 200<=r.getcode()<400 else 1)\""
                  ],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                }
              }
            ]
          }
          EOF
          
          cat task-def.json
          
          # Register new task definition
          aws ecs register-task-definition --cli-input-json file://task-def.json

      - name: Update or Create ECS service
        run: |
          set -eux
          CLUSTER=${{ env.ECS_CLUSTER }}
          SERVICE=${{ env.ECS_BACKEND_SERVICE }}
          TASK_FAMILY=megilance-backend
          # Try update first
          if aws ecs describe-services --cluster $CLUSTER --services $SERVICE --region $AWS_REGION --query 'services[0].serviceName' --output text | grep -q $SERVICE; then
            echo "Service exists - updating"
            aws ecs update-service --cluster $CLUSTER --service $SERVICE --task-definition $TASK_FAMILY --force-new-deployment --region $AWS_REGION || echo "update-service returned non-zero";
          else
            echo "Service not found - creating"
            # Get subnets and security group from previous step
            SUBNETS="${{ steps.vpc-config.outputs.public_subnets }}"
            SG="${{ steps.vpc-config.outputs.security_group }}"
            echo "Using subnets: $SUBNETS"
            echo "Using security group: $SG"
            aws ecs create-service \
              --cluster $CLUSTER \
              --service-name $SERVICE \
              --task-definition $TASK_FAMILY \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],assignPublicIp=ENABLED,securityGroups=[$SG]}" \
              --region $AWS_REGION || (echo "create-service failed"; exit 1)
          fi

      - name: Wait for service stability
        run: |
          aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_BACKEND_SERVICE }}

  deploy-frontend-to-ecs:
    name: Deploy Frontend to ECS
    needs: [preflight-fixes, build-and-push-frontend]
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_frontend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-deploy-frontend
          aws-region: ${{ env.AWS_REGION }}

      - name: Get VPC Configuration
        id: vpc-config
        run: |
          # Get VPC ID
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=megilance-vpc" \
            --query 'Vpcs[0].VpcId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          echo "VPC ID: $VPC_ID"
          
          # Get public subnets - try multiple tag patterns
          PUBLIC_SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=tag:Name,Values=*-public-*" \
            --query 'Subnets[*].SubnetId' \
            --output text \
            --region ${{ env.AWS_REGION }} | tr '\t' ',')
          
          # Fallback: if no public subnets found, get ALL subnets in VPC
          if [ -z "$PUBLIC_SUBNETS" ]; then
            echo "No public subnets found with tag filter, getting all subnets in VPC"
            PUBLIC_SUBNETS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[*].SubnetId' \
              --output text \
              --region ${{ env.AWS_REGION }} | tr '\t' ',')
          fi
          echo "public_subnets=$PUBLIC_SUBNETS" >> $GITHUB_OUTPUT
          echo "Found subnets: $PUBLIC_SUBNETS"
          
          # Get security group
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=group-name,Values=megilance-ecs-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          if [ "$SG_ID" == "None" ] || [ -z "$SG_ID" ]; then
            SG_ID=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" "Name=group-name,Values=default" \
              --query 'SecurityGroups[0].GroupId' \
              --output text \
              --region ${{ env.AWS_REGION }})
          fi
          echo "security_group=$SG_ID" >> $GITHUB_OUTPUT
          echo "Found security group: $SG_ID"

      - name: Create/Update task definition
        run: |
          cat > task-def-frontend.json <<EOF
          {
            "family": "megilance-frontend",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "$(aws iam get-role --role-name megilance-exec-role --query 'Role.Arn' --output text)",
            "containerDefinitions": [
              {
                "name": "frontend",
                "image": "${{ needs.build-and-push-frontend.outputs.image_uri }}",
                "portMappings": [
                  {
                    "containerPort": 3000,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "environment": [
                  {
                    "name": "NODE_ENV",
                    "value": "production"
                  },
                  {
                    "name": "NEXT_PUBLIC_API_URL",
                    "value": "https://api.megilance.com"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/megilance-frontend",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "healthCheck": {
                  "command": [
                    "CMD-SHELL",
                    "node -e \"require('http').get('http://127.0.0.1:3000',res=>process.exit(res.statusCode>=200&&res.statusCode<400?0:1)).on('error',()=>process.exit(1))\""
                  ],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                }
              }
            ]
          }
          EOF
          
          aws ecs register-task-definition --cli-input-json file://task-def-frontend.json

      - name: Update or Create frontend ECS service
        run: |
          set -eux
          CLUSTER=${{ env.ECS_CLUSTER }}
          SERVICE=${{ env.ECS_FRONTEND_SERVICE }}
          TASK_FAMILY=megilance-frontend
          if aws ecs describe-services --cluster $CLUSTER --services $SERVICE --region $AWS_REGION --query 'services[0].serviceName' --output text | grep -q $SERVICE; then
            echo "Frontend service exists - updating"
            aws ecs update-service --cluster $CLUSTER --service $SERVICE --task-definition $TASK_FAMILY --force-new-deployment --region $AWS_REGION || echo "update-service returned non-zero";
          else
            echo "Frontend service not found - creating"
            # Get subnets and security group from previous step
            SUBNETS="${{ steps.vpc-config.outputs.public_subnets }}"
            SG="${{ steps.vpc-config.outputs.security_group }}"
            echo "Using subnets: $SUBNETS"
            echo "Using security group: $SG"
            aws ecs create-service \
              --cluster $CLUSTER \
              --service-name $SERVICE \
              --task-definition $TASK_FAMILY \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],assignPublicIp=ENABLED,securityGroups=[$SG]}" \
              --region $AWS_REGION || (echo "create-service failed"; exit 1)
          fi

      - name: Wait for service stability
        run: |
          aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_FRONTEND_SERVICE }}

  smoke-tests:
    name: Run Smoke Tests
    needs: [deploy-backend-to-ecs, deploy-frontend-to-ecs]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-smoke-tests
          aws-region: ${{ env.AWS_REGION }}

      - name: Get service endpoints (with diagnostics)
        id: endpoints
        run: |
          set -eux
          CLUSTER=${{ env.ECS_CLUSTER }}
          SERVICE=${{ env.ECS_BACKEND_SERVICE }}
          # List tasks - may be empty
          TASK_ARN=$(aws ecs list-tasks --cluster $CLUSTER --service-name $SERVICE --region $AWS_REGION --query 'taskArns[0]' --output text || true)
          echo "task_arn=$TASK_ARN" >> $GITHUB_OUTPUT
          if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" = "None" ]; then
            echo "No task found for service $SERVICE" >&2
            aws ecs describe-services --cluster $CLUSTER --services $SERVICE --region $AWS_REGION --query 'services[0].events' --output json || true
            echo "backend_url=" >> $GITHUB_OUTPUT
            exit 0
          fi
          BACKEND_IP=$(aws ecs describe-tasks --cluster $CLUSTER --tasks $TASK_ARN --region $AWS_REGION --query 'tasks[0].containers[0].networkInterfaces[0].privateIpv4Address' --output text)
          echo "backend_url=http://$BACKEND_IP:8000" >> $GITHUB_OUTPUT

      - name: Test backend health
        run: |
          if [ -z "${{ steps.endpoints.outputs.backend_url }}" ]; then
            echo "No backend URL available, skipping health checks"; exit 0
          fi
          curl -f ${{ steps.endpoints.outputs.backend_url }}/api/health/live || (aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_BACKEND_SERVICE }} --region $AWS_REGION --query 'services[0].events' --output json; exit 1)
          curl -f ${{ steps.endpoints.outputs.backend_url }}/api/health/ready || (aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_BACKEND_SERVICE }} --region $AWS_REGION --query 'services[0].events' --output json; exit 1)

      - name: Test API documentation
        run: |
          if [ -z "${{ steps.endpoints.outputs.backend_url }}" ]; then
            echo "No backend URL available, skipping API docs check"; exit 0
          fi
          curl -f ${{ steps.endpoints.outputs.backend_url }}/api/docs || exit 1

  notify-deployment:
    name: Notify Deployment Status
    needs: [deploy-backend-to-ecs, deploy-frontend-to-ecs, smoke-tests]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend deployed**: ${{ inputs.deploy_backend }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend deployed**: ${{ inputs.deploy_frontend }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Status" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
