name: Auto-Fix AWS Infrastructure

on:
  workflow_dispatch:
    inputs:
      apply_iam_fix:
        description: 'Apply IAM Secrets Manager policy fix'
        required: true
        default: 'true'
        type: boolean
      create_vpc_endpoints:
        description: 'Create VPC endpoints'
        required: true
        default: 'true'
        type: boolean
      force_ecs_update:
        description: 'Force ECS service update'
        required: true
        default: 'true'
        type: boolean

env:
  AWS_REGION: us-east-2

jobs:
  apply-infrastructure-fixes:
    name: Apply Infrastructure Fixes
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
      
      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: github-actions-auto-fix
          aws-region: ${{ env.AWS_REGION }}
      
      - name: âœ… Verify AWS connection
        run: |
          echo "ğŸ” Verifying AWS credentials..."
          ACCOUNT=$(aws sts get-caller-identity --query 'Account' --output text)
          echo "âœ… Connected to AWS Account: $ACCOUNT"
          echo "ğŸ“ Region: ${{ env.AWS_REGION }}"
          echo "ACCOUNT_ID=$ACCOUNT" >> $GITHUB_ENV
      
      - name: ğŸ“‹ Apply IAM Secrets Manager Policy
        if: ${{ inputs.apply_iam_fix }}
        run: |
          echo "ğŸ”§ Creating IAM policy for Secrets Manager access..."
          
          # Create policy JSON
          cat > secrets-policy.json << 'EOF'
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "secretsmanager:GetSecretValue",
                  "secretsmanager:DescribeSecret"
                ],
                "Resource": [
                  "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${ACCOUNT_ID}:secret:megilance/prod/database-*",
                  "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${ACCOUNT_ID}:secret:megilance/prod/jwt-*"
                ]
              },
              {
                "Effect": "Allow",
                "Action": [
                  "kms:Decrypt",
                  "kms:DescribeKey"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF
          
          echo "ğŸ“ Policy JSON created"
          cat secrets-policy.json
          
          # Check if policy exists
          EXISTING_POLICY=$(aws iam list-policies --scope Local --query "Policies[?PolicyName=='megilance-secrets-access'].Arn" --output text || echo "")
          
          if [ -n "$EXISTING_POLICY" ]; then
            echo "â„¹ï¸  Policy already exists: $EXISTING_POLICY"
            POLICY_ARN="$EXISTING_POLICY"
          else
            echo "ğŸ†• Creating new policy..."
            POLICY_ARN=$(aws iam create-policy \
              --policy-name megilance-secrets-access \
              --policy-document file://secrets-policy.json \
              --description "Allow ECS tasks to read secrets from Secrets Manager" \
              --query 'Policy.Arn' \
              --output text)
            echo "âœ… Policy created: $POLICY_ARN"
          fi
          
          # Check if already attached
          ATTACHED=$(aws iam list-attached-role-policies --role-name megilance-exec-role --query 'AttachedPolicies[?PolicyName==`megilance-secrets-access`].PolicyArn' --output text || echo "")
          
          if [ -n "$ATTACHED" ]; then
            echo "â„¹ï¸  Policy already attached to megilance-exec-role"
          else
            echo "ğŸ“ Attaching policy to execution role..."
            aws iam attach-role-policy \
              --role-name megilance-exec-role \
              --policy-arn "$POLICY_ARN"
            echo "âœ… Policy attached successfully"
          fi
          
          # Verify
          echo ""
          echo "ğŸ” Verifying policy attachment..."
          aws iam list-attached-role-policies --role-name megilance-exec-role --query 'AttachedPolicies[*].[PolicyName,PolicyArn]' --output table
          
          echo ""
          echo "âœ… IAM fix completed!"
      
      - name: ğŸŒ Create VPC Endpoints
        if: ${{ inputs.create_vpc_endpoints }}
        run: |
          echo "ğŸŒ Creating VPC endpoints for private AWS service access..."
          
          # Get VPC ID
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=megilance-vpc" \
            --query 'Vpcs[0].VpcId' \
            --output text)
          
          if [ "$VPC_ID" == "None" ] || [ -z "$VPC_ID" ]; then
            echo "âš ï¸  VPC not found, skipping VPC endpoints"
            exit 0
          fi
          
          echo "âœ… VPC ID: $VPC_ID"
          
          # Get VPC CIDR
          VPC_CIDR=$(aws ec2 describe-vpcs --vpc-ids $VPC_ID --query 'Vpcs[0].CidrBlock' --output text)
          echo "   VPC CIDR: $VPC_CIDR"
          
          # Get private subnets
          SUBNET_IDS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=tag:Type,Values=private" \
            --query 'Subnets[*].SubnetId' \
            --output text)
          
          if [ -z "$SUBNET_IDS" ]; then
            echo "âš ï¸  No private subnets found"
            exit 0
          fi
          
          echo "   Private Subnets: $SUBNET_IDS"
          
          # Check if security group exists
          EXISTING_SG=$(aws ec2 describe-security-groups \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=group-name,Values=megilance-vpc-endpoints" \
            --query 'SecurityGroups[0].GroupId' \
            --output text 2>/dev/null || echo "None")
          
          if [ "$EXISTING_SG" != "None" ] && [ -n "$EXISTING_SG" ]; then
            echo "â„¹ï¸  Security group already exists: $EXISTING_SG"
            SG_ID="$EXISTING_SG"
          else
            echo "ğŸ”’ Creating security group..."
            SG_ID=$(aws ec2 create-security-group \
              --group-name megilance-vpc-endpoints \
              --description "Allow HTTPS traffic to VPC endpoints" \
              --vpc-id $VPC_ID \
              --query 'GroupId' \
              --output text)
            
            echo "âœ… Security group created: $SG_ID"
            
            # Add HTTPS ingress rule
            aws ec2 authorize-security-group-ingress \
              --group-id $SG_ID \
              --protocol tcp \
              --port 443 \
              --cidr $VPC_CIDR
            
            echo "âœ… HTTPS ingress rule added"
          fi
          
          # Function to create endpoint
          create_endpoint() {
            local NAME=$1
            local SERVICE=$2
            local TYPE=$3
            
            # Check if exists
            EXISTING=$(aws ec2 describe-vpc-endpoints \
              --filters "Name=vpc-id,Values=$VPC_ID" "Name=service-name,Values=$SERVICE" \
              --query 'VpcEndpoints[0].VpcEndpointId' \
              --output text 2>/dev/null || echo "None")
            
            if [ "$EXISTING" != "None" ] && [ -n "$EXISTING" ]; then
              echo "â„¹ï¸  $NAME endpoint already exists: $EXISTING"
              return 0
            fi
            
            echo "ğŸ“¡ Creating $NAME endpoint..."
            
            if [ "$TYPE" == "Interface" ]; then
              ENDPOINT_ID=$(aws ec2 create-vpc-endpoint \
                --vpc-id $VPC_ID \
                --vpc-endpoint-type Interface \
                --service-name $SERVICE \
                --subnet-ids $SUBNET_IDS \
                --security-group-ids $SG_ID \
                --private-dns-enabled \
                --tag-specifications "ResourceType=vpc-endpoint,Tags=[{Key=Name,Value=megilance-$NAME},{Key=Project,Value=megilance}]" \
                --query 'VpcEndpoint.VpcEndpointId' \
                --output text)
            else
              # Gateway endpoint (S3)
              ROUTE_TABLES=$(aws ec2 describe-route-tables --filters "Name=vpc-id,Values=$VPC_ID" --query 'RouteTables[*].RouteTableId' --output text)
              ENDPOINT_ID=$(aws ec2 create-vpc-endpoint \
                --vpc-id $VPC_ID \
                --vpc-endpoint-type Gateway \
                --service-name $SERVICE \
                --route-table-ids $ROUTE_TABLES \
                --tag-specifications "ResourceType=vpc-endpoint,Tags=[{Key=Name,Value=megilance-$NAME},{Key=Project,Value=megilance}]" \
                --query 'VpcEndpoint.VpcEndpointId' \
                --output text)
            fi
            
            if [ $? -eq 0 ]; then
              echo "âœ… Created $NAME: $ENDPOINT_ID"
            else
              echo "âš ï¸  Failed to create $NAME endpoint"
            fi
          }
          
          # Create endpoints
          echo ""
          echo "ğŸš€ Creating VPC endpoints..."
          create_endpoint "secretsmanager" "com.amazonaws.${{ env.AWS_REGION }}.secretsmanager" "Interface"
          create_endpoint "ecr-api" "com.amazonaws.${{ env.AWS_REGION }}.ecr.api" "Interface"
          create_endpoint "ecr-dkr" "com.amazonaws.${{ env.AWS_REGION }}.ecr.dkr" "Interface"
          create_endpoint "logs" "com.amazonaws.${{ env.AWS_REGION }}.logs" "Interface"
          create_endpoint "s3" "com.amazonaws.${{ env.AWS_REGION }}.s3" "Gateway"
          
          echo ""
          echo "âœ… VPC endpoints creation completed!"
          
          # List all endpoints
          echo ""
          echo "ğŸ“‹ VPC Endpoints:"
          aws ec2 describe-vpc-endpoints \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'VpcEndpoints[*].[VpcEndpointId,ServiceName,State]' \
            --output table
      
      - name: ğŸ”„ Force ECS Service Update
        if: ${{ inputs.force_ecs_update }}
        run: |
          echo "ğŸ”„ Forcing ECS services to restart with new permissions..."
          
          SERVICES=("megilance-backend-service" "megilance-frontend-service")
          
          for SERVICE in "${SERVICES[@]}"; do
            echo ""
            echo "ğŸ”§ Updating $SERVICE..."
            
            # Check if service exists
            SERVICE_EXISTS=$(aws ecs describe-services \
              --cluster megilance-cluster \
              --services $SERVICE \
              --query 'services[0].serviceName' \
              --output text 2>/dev/null || echo "None")
            
            if [ "$SERVICE_EXISTS" == "None" ] || [ -z "$SERVICE_EXISTS" ]; then
              echo "âš ï¸  Service not found: $SERVICE"
              continue
            fi
            
            # Force new deployment
            aws ecs update-service \
              --cluster megilance-cluster \
              --service $SERVICE \
              --force-new-deployment \
              --query 'service.{Name:serviceName,Status:status,Running:runningCount,Desired:desiredCount}' \
              --output table
            
            echo "âœ… $SERVICE deployment triggered"
          done
          
          echo ""
          echo "âœ… All ECS services updated!"
          echo "â„¹ï¸  New tasks will start with updated IAM permissions"

      - name: ğŸ› ï¸ Tune ECS Health Check Grace Period (optional)
        if: ${{ inputs.force_ecs_update }}
        continue-on-error: true
        run: |
          echo "ğŸ› ï¸ Adjusting health check grace period to reduce premature failures..."
          # Backend often needs longer startup time
          aws ecs update-service \
            --cluster megilance-cluster \
            --service megilance-backend-service \
            --health-check-grace-period-seconds 120 \
            --query 'service.{Name:serviceName,Grace:healthCheckGracePeriodSeconds}' \
            --output table || true
          
          # Frontend usually faster; set modest grace period
          aws ecs update-service \
            --cluster megilance-cluster \
            --service megilance-frontend-service \
            --health-check-grace-period-seconds 60 \
            --query 'service.{Name:serviceName,Grace:healthCheckGracePeriodSeconds}' \
            --output table || true
      
      - name: ğŸ“Š Monitor Service Health
        run: |
          echo "ğŸ“Š Monitoring ECS service health..."
          echo "â³ Waiting 60 seconds for tasks to start stopping..."
          sleep 60
          
          SERVICES=("megilance-backend-service" "megilance-frontend-service")
          
          for SERVICE in "${SERVICES[@]}"; do
            echo ""
            echo "ğŸ‘€ Monitoring $SERVICE..."
            
            for i in {1..10}; do
              STATUS=$(aws ecs describe-services \
                --cluster megilance-cluster \
                --services $SERVICE \
                --query 'services[0].{Running:runningCount,Desired:desiredCount,Deployment:deployments[0].rolloutState}' \
                --output json 2>/dev/null || echo "{}")
              
              if [ -n "$STATUS" ] && [ "$STATUS" != "{}" ]; then
                RUNNING=$(echo $STATUS | jq -r '.Running')
                DESIRED=$(echo $STATUS | jq -r '.Desired')
                ROLLOUT=$(echo $STATUS | jq -r '.Deployment')
                
                echo "   [$i/10] Running: $RUNNING/$DESIRED - Rollout: $ROLLOUT"
                
                if [ "$RUNNING" == "$DESIRED" ] && [ "$ROLLOUT" == "COMPLETED" ]; then
                  echo "   âœ… $SERVICE is stable!"
                  break
                fi
              fi
              
              if [ $i -lt 10 ]; then
                sleep 30
              fi
            done
          done
      
      - name: ğŸ‰ Summary
        if: always()
        run: |
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ‰ Automated Infrastructure Fix Complete!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "âœ… Actions Completed:"
          if [ "${{ inputs.apply_iam_fix }}" == "true" ]; then
            echo "   â€¢ IAM Secrets Manager policy applied"
          fi
          if [ "${{ inputs.create_vpc_endpoints }}" == "true" ]; then
            echo "   â€¢ VPC endpoints created"
          fi
          if [ "${{ inputs.force_ecs_update }}" == "true" ]; then
            echo "   â€¢ ECS services updated"
          fi
          echo ""
          echo "ğŸ“‹ Next Steps:"
          echo "   1. Check ECS task status:"
          echo "      aws ecs describe-tasks --cluster megilance-cluster --tasks \$(aws ecs list-tasks --cluster megilance-cluster --service-name megilance-backend-service --query 'taskArns[0]' --output text) --region ${{ env.AWS_REGION }}"
          echo ""
          echo "   2. View CloudWatch logs:"
          echo "      aws logs tail /ecs/megilance-backend --follow --region ${{ env.AWS_REGION }}"
          echo ""
          echo "   3. If successful, re-run the main deployment workflow:"
          echo "      gh workflow run auto-deploy.yml"
          echo ""
