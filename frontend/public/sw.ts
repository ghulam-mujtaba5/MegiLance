// @AI-HINT: PWA Service Worker for offline support and caching
// Production-ready with workbox strategies and precaching

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, Route } from 'workbox-routing';
import {
  NetworkFirst,
  CacheFirst,
  StaleWhileRevalidate,
} from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

declare const self: ServiceWorkerGlobalScope;

// ============================================================================
// Precaching
// ============================================================================

// Precache all assets generated by build process
precacheAndRoute(self.__WB_MANIFEST);

// Clean up old caches
cleanupOutdatedCaches();

// ============================================================================
// Cache Names
// ============================================================================

const CACHE_NAMES = {
  pages: 'pages-cache-v1',
  images: 'images-cache-v1',
  fonts: 'fonts-cache-v1',
  api: 'api-cache-v1',
  static: 'static-cache-v1',
};

// ============================================================================
// API Routes - Network First with Fallback
// ============================================================================

// API requests - always try network first
registerRoute(
  ({ url }) => url.pathname.startsWith('/backend/api'),
  new NetworkFirst({
    cacheName: CACHE_NAMES.api,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
    networkTimeoutSeconds: 10,
  })
);

// ============================================================================
// Static Assets - Cache First
// ============================================================================

// JavaScript and CSS files
registerRoute(
  ({ request }) =>
    request.destination === 'script' || request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: CACHE_NAMES.static,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// ============================================================================
// Images - Cache First with Long Expiry
// ============================================================================

registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: CACHE_NAMES.images,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 24 * 60 * 60, // 60 days
      }),
    ],
  })
);

// ============================================================================
// Fonts - Cache First with Long Expiry
// ============================================================================

registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: CACHE_NAMES.fonts,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  })
);

// ============================================================================
// Pages - Network First
// ============================================================================

registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: CACHE_NAMES.pages,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  })
);

// ============================================================================
// Background Sync for Offline Actions
// ============================================================================

// Queue for offline message sending
const messageSyncPlugin = new BackgroundSyncPlugin('messageQueue', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 hours
});

registerRoute(
  ({ url }) => url.pathname.startsWith('/backend/api/messages'),
  new NetworkFirst({
    plugins: [messageSyncPlugin],
  }),
  'POST'
);

// Queue for offline proposal submissions
const proposalSyncPlugin = new BackgroundSyncPlugin('proposalQueue', {
  maxRetentionTime: 24 * 60,
});

registerRoute(
  ({ url }) => url.pathname.startsWith('/backend/api/proposals'),
  new NetworkFirst({
    plugins: [proposalSyncPlugin],
  }),
  'POST'
);

// ============================================================================
// Push Notifications
// ============================================================================

self.addEventListener('push', (event) => {
  if (!event.data) return;

  try {
    const data = event.data.json();
    
    const options: NotificationOptions = {
      body: data.body || 'You have a new notification',
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      vibrate: [100, 50, 100],
      data: {
        url: data.url || '/',
        timestamp: Date.now(),
      },
      actions: data.actions || [],
      tag: data.tag || 'default',
      renotify: true,
    };

    event.waitUntil(
      self.registration.showNotification(data.title || 'MegiLance', options)
    );
  } catch (error) {
    console.error('Push notification error:', error);
  }
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const url = event.notification.data?.url || '/';

  event.waitUntil(
    self.clients.matchAll({ type: 'window' }).then((clients) => {
      // Try to focus an existing window
      for (const client of clients) {
        if (client.url === url && 'focus' in client) {
          return client.focus();
        }
      }
      // Open new window if none exists
      return self.clients.openWindow(url);
    })
  );
});

// ============================================================================
// Installation & Activation
// ============================================================================

self.addEventListener('install', (event) => {
  console.log('[SW] Installing service worker');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker');
  event.waitUntil(self.clients.claim());
});

// ============================================================================
// Message Handling
// ============================================================================

self.addEventListener('message', (event) => {
  if (event.data?.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data?.type === 'GET_VERSION') {
    event.ports[0]?.postMessage({ version: '1.0.0' });
  }
  
  if (event.data?.type === 'CLEAR_CACHE') {
    event.waitUntil(
      caches.keys().then((keys) =>
        Promise.all(keys.map((key) => caches.delete(key)))
      )
    );
  }
});

// ============================================================================
// Offline Fallback
// ============================================================================

// Return offline page for failed navigation requests
const offlineFallback = new Route(
  ({ request }) => request.mode === 'navigate',
  async ({ event }) => {
    try {
      return await new NetworkFirst({
        cacheName: CACHE_NAMES.pages,
      }).handle({ event, request: event.request });
    } catch (error) {
      // Return cached offline page
      const cache = await caches.open(CACHE_NAMES.pages);
      const offlinePage = await cache.match('/offline');
      if (offlinePage) return offlinePage;
      
      // Fallback response
      return new Response(
        `<!DOCTYPE html>
        <html>
          <head>
            <title>Offline - MegiLance</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
              body { font-family: system-ui, sans-serif; text-align: center; padding: 40px; }
              h1 { color: #4573df; }
            </style>
          </head>
          <body>
            <h1>You're Offline</h1>
            <p>Please check your internet connection and try again.</p>
            <button onclick="location.reload()">Retry</button>
          </body>
        </html>`,
        { headers: { 'Content-Type': 'text/html' } }
      );
    }
  }
);

registerRoute(offlineFallback);

export {};
